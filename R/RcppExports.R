# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Generate from and evaluate the density of the matrix normal distribution
#' @param M \code{p * q} mean matrix
#' @param Q \code{q * q} covariance matrix
#' @param P \code{p * p} covariance matrix
#' @return For \code{rmatn} a matrix \code{X}, for \code{dmatn} the (logarithm of) the density evaluation.
#' @examples
#' set.seed(100)
#' p <- 20
#' q <- 5
#' M <- matrix(rnorm(p*q), p, q)
#' P <- crossprod(matrix(rnorm(p*p), p, p))
#' Q <- crossprod(matrix(rnorm(q*q), q, q))
#' X <- rmatn(M, Q, P)
#' dmatn(X, M, Q, P, logd = TRUE)
rmatn <- function(M, Q, P) {
    .Call(`_fdr_rmatn`, M, Q, P)
}

#' @rdname rmatn
#' @param X \code{p * q} matrix at which to evaluate the density
#' @param logd logical; if \code{TRUE} the logarithm of the density is returned
dmatn <- function(X, M, Q, P, logd = FALSE) {
    .Call(`_fdr_dmatn`, X, M, Q, P, logd)
}

#' Generate from and evaluate the density of the inverse Wishart distribution
#' @param v degrees of freedom (integer)
#' @param S \code{q * q} scale matrix
#' @return For \code{rinvwish} a matrix \code{Sigma}, for \code{dinvwish} the (logarithm of) the density evaluation.
#' set.seed(100)
#' q <- 5
#' v <- 10
#' S <- crossprod(matrix(rnorm(q*q), q, q))
#' Sigma <- rinvwish(v, S)
#' dinvwish(Sigma, v, S, logd = TRUE)
rinvwish <- function(v, S) {
    .Call(`_fdr_rinvwish`, v, S)
}

#' @rdname rinvwish
#' @param Sigma \code{q * q} matrix at which to evaluate the density
#' @param logd logical; if \code{TRUE} the logarithm of the density is returned
dinvwish <- function(Sigma, v, S, logd = FALSE) {
    .Call(`_fdr_dinvwish`, Sigma, v, S, logd)
}

#' Generate from and evaluate the density of the multivariate normal distribution
#' @param m mean vector (length \code{p})
#' @param Sigma \code{p * p} covariance matrix
#' @return For \code{rmultn} a vector \code{x}, for \code{dmultn} the (logarithm of) the density evaluation.
#' set.seed(100)
#' p <- 20
#' m <- rnorm(p)
#' Sigma <- crossprod(matrix(rnorm(p*p), p, p))
#' x <- rmultn(m, Sigma)
#' dmultn(x, m, Sigma, logd = TRUE)
rmultn <- function(m, Sigma) {
    .Call(`_fdr_rmultn`, m, Sigma)
}

#' @rdname rmultn
#' @param x \code{n * p} matrix at which to evaluate the density
#' @param logd logical; if \code{TRUE} the logarithm of the density is returned
dmultn <- function(x, m, Sigma, logd = FALSE) {
    .Call(`_fdr_dmultn`, x, m, Sigma, logd)
}

